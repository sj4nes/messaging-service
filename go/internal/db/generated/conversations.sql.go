// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listConversations = `-- name: ListConversations :many
SELECT id::text, key, channel, participant_a, participant_b, message_count, last_activity_at
FROM conversations
ORDER BY last_activity_at DESC
LIMIT $1 OFFSET $2
`

type ListConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListConversationsRow struct {
	ID             string             `json:"id"`
	Key            pgtype.Text        `json:"key"`
	Channel        pgtype.Text        `json:"channel"`
	ParticipantA   pgtype.Text        `json:"participant_a"`
	ParticipantB   pgtype.Text        `json:"participant_b"`
	MessageCount   int32              `json:"message_count"`
	LastActivityAt pgtype.Timestamptz `json:"last_activity_at"`
}

func (q *Queries) ListConversations(ctx context.Context, arg ListConversationsParams) ([]ListConversationsRow, error) {
	rows, err := q.db.Query(ctx, listConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConversationsRow
	for rows.Next() {
		var i ListConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Channel,
			&i.ParticipantA,
			&i.ParticipantB,
			&i.MessageCount,
			&i.LastActivityAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
